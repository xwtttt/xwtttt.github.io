<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随机波动</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-04T13:06:11.614Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xwtttt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模型选择</title>
    <link href="http://yoursite.com/2020/04/09/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>http://yoursite.com/2020/04/09/%E8%BF%87%E6%8B%9F%E5%90%88/</id>
    <published>2020-04-09T09:18:28.000Z</published>
    <updated>2020-05-04T13:06:11.614Z</updated>
    
    <content type="html"><![CDATA[<p>模型选择、过拟合和欠拟合</p><a id="more"></a><h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><h2 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h2><p>在了解过拟合和欠拟合之前我们收先了解一下什么是<strong>训练误差</strong>和<strong>泛化误差</strong>。</p><p>通俗来讲，<strong>训练误差</strong>就是模型在训练集上的误差，<strong>泛化误差</strong>就是模型在测试集上的误差。</p><p>当一个模型的参数越多，就代表它越复杂，经过训练集的训练就越容易拟合训练集上的数据，但是在测试集上不一定。这就好比是考试，一个记住了所有模拟考试答案的学生，再真正的高考中也不一定能取得很高的分数。</p><p> 所以深度学习应该关注<strong>泛化误差</strong></p><h3 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h3><p>在实际应用中，由于数据并不容易获取，测试数据极少用一次就丢弃。因此，实践中验证数据集和测试数据集的界限可能比较模糊。当训练数据不够用的时候，预留大量的验证数据显得十分奢侈，一种通常的做法是<strong>K折交叉验证</strong>。</p><p>在 <strong>K 折交叉验证</strong>之中，我们将数据分成 <strong>K</strong> 个不同的子集，做 <strong>K</strong> 次模型训练和验证。每一次，我们使用一个子数据集验证模型，并且使用其他 <strong>K-1</strong> 个数据对模型进行训练。最后，我们对这 <strong>K</strong> 次训练误差和验证误差分别求平均。</p><h1 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h1><p><strong>过拟合</strong>是指模型在训练集上的误差远小于在测试集上的误差。</p><p><strong>欠拟合</strong>是指模型无法获得较小的训练误差。</p><h2 id="模型复杂度"><a href="#模型复杂度" class="headerlink" title="模型复杂度"></a>模型复杂度</h2><p>模型复杂度是导致过拟合的原因之一。</p><p>我们以 K 阶多项式拟合函数为例：</p><script type="math/tex; mode=display">\hat{y} = b + \sum_{k=1}^K x^k w_k</script><p>其中 $w_k$ 是权重参数，$b$ 是偏差参数。（特别地，一阶多项式函数拟合又叫线性函数拟合。）</p><p>由于高阶多项式函数模型的参数多，模型函数的选择空间更大，所以高阶多项式比低阶多项式的复杂程度高。</p><p>复杂程度较高的模型会相对容易地在训练集上获得较小的误差，但是相应的也容易出现<strong>过拟合</strong>的现象。复杂程度较低的模型很难在训练集上取得较小的误差，会出现<strong>欠拟合</strong>的现象。应对欠拟合和过拟合的一个办法就是针对数据集选择合适复杂度的模型。</p><p><img src="../img/capacity_vs_error.svg" alt="模型复杂度对欠拟合和过拟合的影响"></p><h2 id="训练数据集大小"><a href="#训练数据集大小" class="headerlink" title="训练数据集大小"></a>训练数据集大小</h2><p>影响欠拟合和过拟合的另一个重要因素是训练数据集的大小。一般来说，如果训练数据集中样本数过少，特别是比模型参数数量（按元素计）更少时，过拟合更容易发生。此外，泛化误差不会随训练数据集里样本数量增加而增大。因此，在计算资源允许的范围之内，我们通常希望训练数据集大一些，特别是在模型复杂度较高时，例如层数较多的深度学习模型。</p><h1 id="减小过拟合的方法"><a href="#减小过拟合的方法" class="headerlink" title="减小过拟合的方法"></a>减小过拟合的方法</h1><p>常见的减小过拟合的方法有<strong>权重衰减法</strong>，等价于<strong>$L2$范数正则化</strong>，通俗来讲就是添加一个<strong>$L2$范数惩罚项</strong>。</p><p>我们先来介绍一下什么是<strong>$L2$范数正则化</strong>：<strong>$L2$范数正则化</strong>就是模型的权重参数的平方和与一个正的常数的乘积，以线性回归的损失函数为例：</p><script type="math/tex; mode=display">\ell(w_1, w_2, b) = \frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right)^2</script><p>其中$w_1, w_2$是权重参数，$b$是偏差参数，样本$i$的输入为$x_1^{(i)}, x_2^{(i)}$，标签为$y^{(i)}$，样本数为$n$。将权重参数用向量$\boldsymbol{w} = [w_1, w_2]$表示，带有$L_2$范数惩罚项的新损失函数为</p><script type="math/tex; mode=display">\ell(w_1, w_2, b) + \frac{\lambda}{2n} \|\boldsymbol{w}\|^2</script><p>其中超参数$\lambda &gt; 0$。当权重参数均为0时，惩罚项最小。当$\lambda$较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素较接近0。当$\lambda$设为0时，惩罚项完全不起作用。上式中$L_2$范数平方$|\boldsymbol{w}|^2$展开后得到$w_1^2 + w_2^2$。有了$L_2$范数惩罚项后，在小批量随机梯度下降中，我们可以将权重的迭代方式改为：</p><script type="math/tex; mode=display">\begin{aligned}w_1 &\leftarrow \left(1- \frac{\eta\lambda}{|\mathcal{B}|} \right)w_1 -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_1^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right),\\w_2 &\leftarrow \left(1- \frac{\eta\lambda}{|\mathcal{B}|} \right)w_2 -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_2^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right).\end{aligned}</script><p>可见，$L_2$范数正则化令权重$w_1$和$w_2$先自乘小于1的数，再减去不含惩罚项的梯度。因此，$L_2$范数正则化又叫权重衰减。权重衰减通过惩罚绝对值较大的模型参数为需要学习的模型增加了限制，这可能对过拟合有效。实际场景中，我们有时也在惩罚项中添加偏差元素的平方和。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模型选择、过拟合和欠拟合&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>反向传播</title>
    <link href="http://yoursite.com/2020/04/09/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2020/04/09/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</id>
    <published>2020-04-09T05:37:06.000Z</published>
    <updated>2020-04-10T16:50:47.204Z</updated>
    
    <content type="html"><![CDATA[<p>正向传播，反向传播</p><a id="more"></a><h1 id="反向传播简介"><a href="#反向传播简介" class="headerlink" title="反向传播简介"></a>反向传播简介</h1><h2 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h2><p>在解释什么是反向传播之前，我们先来了解一下正向传播的过程：</p><p>我们首先考虑一个两层的神经网络：</p><script type="math/tex; mode=display">z^{(1)} = W^{(1)}x + b^{(1)}</script><p>其中 $w^{(1)}$ 为第一层的权重参数，$b^{(1)}$ 为第一层的偏差项，然后我们将它放入激活函数 $\phi$ 可以得到：</p><script type="math/tex; mode=display">a^{(1)} =\phi (z^{(1)})</script><p>然后我们将他放入第二层神经网络：</p><script type="math/tex; mode=display">z^{(2)} = W^{(2)}a^{(1)} + b^{(2)}</script><p>接着放入激活函数得到我们的预测结果：</p><script type="math/tex; mode=display">\hat{y} = \phi(z^{(2)})</script><p>假设损失函数为 $\ell$ ,且样本标签为 $y$ ,则可以计算出单个数据样本的损失项</p><script type="math/tex; mode=display">L = \ell(\hat{y},y)</script><p>而我们的目标就是最小化这个损失函数。</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正向传播，反向传播&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>标准化和归一化</title>
    <link href="http://yoursite.com/2020/04/05/%E5%BD%92%E4%B8%80%E5%8C%96%E5%92%8C%E6%A0%87%E5%87%86%E5%8C%96/"/>
    <id>http://yoursite.com/2020/04/05/%E5%BD%92%E4%B8%80%E5%8C%96%E5%92%8C%E6%A0%87%E5%87%86%E5%8C%96/</id>
    <published>2020-04-05T06:52:03.000Z</published>
    <updated>2020-04-05T09:05:45.178Z</updated>
    
    <content type="html"><![CDATA[<p>介绍标准化和归一化</p><a id="more"></a><h1 id="标准化和归一化"><a href="#标准化和归一化" class="headerlink" title="标准化和归一化"></a>标准化和归一化</h1><p>在我们进行数据处理的时候，常常会碰到量纲或者数量级不同的数值。当各个指标之间相差很大的时候，直接使用原始数据进行分析会使得数值较高的指标对综合分析的影响较大，而数值较低的指标对综合分析的影响较小。</p><p>假设一个房价预测模型，自变量为面积和房间数，因变量为房价：</p><script type="math/tex; mode=display">y = \theta_1x_1 + \theta_2x_2+b</script><p>其中 $x_1$ 代表房间数，$x_2$ 代表面积，那么在未进行标准化前，其实 $x_2$ 的变化对于数据的影响远远大于 $x_1$ </p><p>因此我们要进行标准化，使数据落入一个小的特定区间，便于不同的单位或者量级的指标能够进行比较和加权。</p><p>本文主要介绍两个方法：min-max 方法和 z-score 方法</p><h2 id="规范化方法（min-max-方法）："><a href="#规范化方法（min-max-方法）：" class="headerlink" title="规范化方法（min-max 方法）："></a>规范化方法（min-max 方法）：</h2><p>对序列 $x_1, x_2, …, x_n$ 进行变换：</p><script type="math/tex; mode=display">y_i = \frac{X_i - X_{min}}{X_{max} - X_{min}}</script><p>这样得到的新序列 $y_1, y_2, …, y_n \in [0,1]$ 且无量纲</p><h2 id="正规化方法（z-score-方法）："><a href="#正规化方法（z-score-方法）：" class="headerlink" title="正规化方法（z-score 方法）："></a>正规化方法（z-score 方法）：</h2><p>对序列 $x_1, x_2, …, x_n$ 进行变换：</p><script type="math/tex; mode=display">y_i = \frac{x_i - \overline{x}}{s}</script><p>其中 $\overline{x}$ 为序列 $x$ 的平均值，$s$ 为序列 $x$ 的标准差：</p><script type="math/tex; mode=display">\overline{x} = \frac{1}{n}\sum_{i=1}^{n}xi</script><script type="math/tex; mode=display">s = \sqrt{\frac{1}{n-1}\sum_{i=1}^{n}(x_i-\overline{x})^2}</script><p>于是生成的新序列 $y_1, y_2, …, y_n$ 的均值为 0，方差为 1，而且无量纲。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍标准化和归一化&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线性回归实战-kaggle房价预测模型</title>
    <link href="http://yoursite.com/2020/04/05/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AE%9E%E6%88%98-kaggle%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/04/05/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AE%9E%E6%88%98-kaggle%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-04-05T05:19:03.000Z</published>
    <updated>2020-04-07T09:38:17.057Z</updated>
    
    <content type="html"><![CDATA[<p>kaggle 上的一个线性回归小项目</p><a id="more"></a><h1 id="房价预测模型"><a href="#房价预测模型" class="headerlink" title="房价预测模型"></a>房价预测模型</h1><h2 id="kaggle竞赛"><a href="#kaggle竞赛" class="headerlink" title="kaggle竞赛"></a>kaggle竞赛</h2><p><strong>kaggle </strong>是一个深度学习竞赛的网站，上面有官方提供的整理好的数据集供深度学习爱好者们进行训练，同时可以提交以进行预测准确度排名，排名靠前的可以获得奖励</p><p>本项目采用 kaggle 上的房价预测模型进行训练，网址是：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" target="_blank" rel="noopener">https://www.kaggle.com/c/house-prices-advanced-regression-techniques</a></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>本项目采用框架为 <strong>mxnet</strong>，使用 pandas 进行数据的预处理，首先导入需要的使用的包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> d2lzh <span class="keyword">as</span> d2l</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, gluon, nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata, loss <span class="keyword">as</span> gloss, nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><p>kaggle 上提供的数据是两个 csv 文件，下面使用 pandas 读取这两个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">'./train.csv'</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">'./test.csv'</span>)</span><br></pre></td></tr></table></figure><p><code>train_data</code>是一个 (1460, 81) 的数据，包含 1460 个样本、80个特征和 1 个标签</p><p><code>test_data</code>是一个 (1459, 80)的数据，包含 1459 个样本，80个特征。</p><p>我们需要将<code>test_data</code>中每个样本的标签 (即 SalePrice) 预测出来。</p><p>其中<code>train_data</code>和<code>test_data</code>的第一个特征都是 ‘id’ ，我们不需要所以不用它来训练。我们将所有训练数据和测试数据的 79 个特征按照样本进行链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:<span class="number">-1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><p>接下来我们取出其中数值类型的数据并对其进行<strong><a href="./归一化和标准化.md">标准化</a></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">'object'</span>].index</span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">lamda x: (x - x.mean()) / (x.std()))</span><br></pre></td></tr></table></figure><p>标准化后，每个特征的均值为 0，因此可以使用 0 代替确实的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>接下来将离散的数据转化为指示的特征。</p><p>举个例子，假设特征 MSZoning 里面有两个不同的离散值 RL 和 RM ，那么这一步转换将去掉 MSZoning 特征，并新加两个特征 MSZoning_RL 和 MSZoning_RM，其值为 0 或 1 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_features = pd.get_dummies(all_features, dummy_na = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>接下来通过 <code>values</code> 属性提取出 <code>train_features</code> 和 <code>test_features</code> 并转换为 NDArray 方便后面的训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n_train = train_data.shape[<span class="number">0</span>]</span><br><span class="line">train_features = nd.array(all_features[:n_train].values)</span><br><span class="line">test_features = nd.array(all_features[n_train:].values)</span><br><span class="line">train_labels = nd.array(train_data.SalesPrice.values).reshape((<span class="number">-1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>根据公式</p><script type="math/tex; mode=display">L = \frac{1}{2} \sum_i \vert {label}_i - {pred}_i \vert^2</script><p>定义损失函数模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loss = gloss.L2Loss()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span><span class="params">()</span>:</span></span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    net.add(nn.Dense(<span class="number">1</span>))</span><br><span class="line">    net.initialize()</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>下面定义比赛用来<strong><em>评价</em></strong>模型的对数均方根误差。</p><p>给定预测值 $\hat y_1, \ldots, \hat y_n$ 和对应的真实标签 $y_1,\ldots, y_n$，它的定义为</p><script type="math/tex; mode=display">\sqrt{\frac{1}{n}\sum_{i=1}^n\left(\log(y_i)-\log(\hat y_i)\right)^2}</script><p>对数均方根误差的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_rmse</span><span class="params">(net,features,labels)</span>:</span></span><br><span class="line"><span class="comment"># clipped_preds 为在1到正无穷之间取值，小于1的置为1</span></span><br><span class="line">    clipped_preds = nd.clip(net(features), <span class="number">1</span>, float(<span class="string">'inf'</span>))</span><br><span class="line">    <span class="comment"># 定义均方差</span></span><br><span class="line">    rmse = nd.sqrt(<span class="number">2</span> * loss(clipped_preds.log(), labels.log()).mean())</span><br><span class="line">    <span class="comment"># 返回标量</span></span><br><span class="line">    <span class="keyword">return</span> rmse.asscalar()</span><br></pre></td></tr></table></figure><p>接下来定义我们的训练函数，这里我们不使用小批量随机梯度下降法，我们使用 <strong><em>Adam 优化算法</em></strong>，它对于学习率没有那么敏感：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(net, train_features, train_labels, test_features, test_labels,</span></span></span><br><span class="line"><span class="function"><span class="params">         num_epochs, learning_rate, weight_decay, batch_size)</span>:</span></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = gdata.DataLoader(gdata.ArrayDataset(train_features,train_labels),</span><br><span class="line">                                  batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 这里使用 Adam 优化算法</span></span><br><span class="line">    trainer = gluon.Trainer(net.collect_params(), <span class="string">'adam'</span>, &#123;</span><br><span class="line">        <span class="string">'learning_rate'</span>: learning_rate,</span><br><span class="line">        <span class="string">'wd'</span>: weight_decay</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            <span class="comment"># 按照小批量梯度下降更新梯度，所以要除以 batch_size</span></span><br><span class="line">            trainer.step(batch_size)</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><p>由于数据量宝贵，所以我们这里使用 <strong>k 折交叉验证方法</strong>。下面实现一个函数，它返回第 i 折交叉验证时所需要的训练和验证数据，其中第 i 折为验证集，第 i -1 折为训练集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_k_fold_data</span><span class="params">(k,i,X,y)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="comment"># 选择第 j 组数据为数据集，第 i 组数据为验证集</span></span><br><span class="line">        idx = slice(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = nd.concat(X_train, X_part, dim=<span class="number">0</span>)</span><br><span class="line">            y_train = nd.concat(y_train, y_part, dim=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br></pre></td></tr></table></figure><p>在 k 折交叉验证中我们训练 k 次并返回训练和验证的平均误差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold</span><span class="params">(k, X_train, y_train, num_epochs, learning_rate, weight_decay,</span></span></span><br><span class="line"><span class="function"><span class="params">           batch_size)</span>:</span></span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()</span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,</span><br><span class="line">                                   weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[<span class="number">-1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epochs'</span>, <span class="string">'rmse'</span>,</span><br><span class="line">                         range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), valid_ls,</span><br><span class="line">                         [<span class="string">'train'</span>, <span class="string">'valid'</span>])</span><br><span class="line">        print(<span class="string">'flod %d, train rmse %f, valid rmse %f'</span> %</span><br><span class="line">              (i, train_ls[<span class="number">-1</span>], valid_ls[<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><p>接下来我们选择一组参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k, num_epochs, lr, weight, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br></pre></td></tr></table></figure><p> 返回训练误差和验证平均误差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_l, valid_loss = (k, train_features, train_labels, num_epochs, lr,</span><br><span class="line">                      weight_decay, batch_size)</span><br><span class="line">print(<span class="string">'%d - fold validation: avg train rmse %f, avg valid rmse %f'</span> % </span><br><span class="line">      (k, train_l, valid_l))</span><br></pre></td></tr></table></figure><h2 id="预测并在-kaggle-上提交结果"><a href="#预测并在-kaggle-上提交结果" class="headerlink" title="预测并在 kaggle 上提交结果"></a>预测并在 kaggle 上提交结果</h2><p>下面定义预测函数。在预测之前，我们会使用完整的训练数据集来重新训练模型，并将预测的结果储存为提交所需要的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_pred</span><span class="params">(train_features, test_features, train_labels, test_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                  num_epochs, lr, weight_decay, batch_size)</span>:</span></span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">                       num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.semilogy(range(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">'epoch'</span>, <span class="string">'rmse'</span>)</span><br><span class="line">    print(<span class="string">'train rmse %f'</span> % train_ls[<span class="number">-1</span>])</span><br><span class="line">    preds = net(test_features).asnumpy()</span><br><span class="line">    test_data[<span class="string">'SalesPrice'</span>] = pd.Series(preds.reshape(<span class="number">1</span>, <span class="number">-1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">'Id'</span>], test_data[<span class="string">'SalesPrice'</span>]], axis = <span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">'submission.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">train_and_pred(train_features, test_features, train_labels, test_data,</span><br><span class="line">               num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><p>如此我们就生成了一个<code>.csv</code>的预测数据集，可以上传到 kaggle 并查看排名啦~</p><h2 id="提升排名"><a href="#提升排名" class="headerlink" title="提升排名"></a>提升排名</h2><p>如果想要获得更好的预测结果，我们可以尝试调整 <code>lr</code> 或者 <code>weight_decay</code>，或者增加隐藏层以及节点数，慢慢调参~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kaggle 上的一个线性回归小项目&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动量梯度下降法</title>
    <link href="http://yoursite.com/2020/04/02/%E5%8A%A8%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/02/%E5%8A%A8%E9%87%8F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-02T13:08:20.000Z</published>
    <updated>2020-04-05T04:58:51.874Z</updated>
    
    <content type="html"><![CDATA[<p>动量梯度下降算法的小总结<br><a id="more"></a></p><h1 id="动量梯度下降法"><a href="#动量梯度下降法" class="headerlink" title="动量梯度下降法"></a>动量梯度下降法</h1><h2 id="指数加权滑动平均"><a href="#指数加权滑动平均" class="headerlink" title="指数加权滑动平均"></a>指数加权滑动平均</h2><p>在谈论什么是<strong>动量梯度下降法</strong>之前，我们先来谈论一下什么是<strong>指数加权滑动平均</strong>。</p><p>当你想计算数据的平均，比如下图就是伦敦一年的天气统计数据</p><p><img src="/img/weather.jpg" alt></p><p>如果你想计算一年中温度的趋势，即局部平均或者滑动平均，你可以这么做：</p><script type="math/tex; mode=display">v_0 = 0\\v_2 = 0.9v_1 + 0.1\theta_1\\v_3 = 0.9v_2 + 0.1\theta_2\\...\\v_t = 0.9v_{t-1} + 0.1\theta_t\\</script><p>其中 $ v_t $ 代表 $\frac{1}{1-\beta}$ 天温度的平均（为什么下面会讲），$\theta_t$ 代表第 $t$ 天的温度。<br>于是我们给出公式：</p><script type="math/tex; mode=display">v_t = \beta v_{t-1} + (1-\beta)\theta_t</script><p>例如：</p><p>$\beta = 0.9$ 时，$v_t$ 代表前十天温度的平均。</p><p>$\beta = 0.98$ 时，$v_t$ 代表前 五十天温度的平均。</p><p>我们假设 $\beta = 0.9$，按照降序排列，列出相应的等式了解一下它是如何计算每日气温的：</p><script type="math/tex; mode=display">v_{100} = 0.9v_{99} + 0.1\theta_{100}\\v_{99} = 0.9v_{98} + 0.1\theta_{99}\\v_{98} = 0.9v_{97} + 0.1\theta_{98}\\...</script><p>将式子化简，我们于是有：</p><script type="math/tex; mode=display">v_{100} = 0.1\theta_{100} + 0.9\times 0.1\theta_{99} + 0.9^2\times 0.1\theta_{98} + 0.9^3\times 0.1\theta_{97} + ...</script><p>这就是我们对第 100 天数据的预测。</p><p>我们可以看到，这个预测就是其实是一个不断衰减的系数（$0.1, 0.9\times0.1, 0.9^2\times0.1, 0.9^3\times0.1…$）乘以 $\theta_i$，其中这个不断衰减的系数就叫<strong>指数衰减函数</strong>，意味着这个温度的权重从当天开始向前推，每一天的权重都在下降。</p><p>然后我们可能好奇，这到底是前几天的气温平均值呢？</p><p>还是用 $\beta = 0.9$ 时举例：</p><script type="math/tex; mode=display">0.9^{10}\approx\frac{1}{e}</script><p>即经过10天的时间，指数衰减函数能降到峰值的 $\frac{1}{e}$ 左右。换句话说，十天之前的数据对当前温度的计算影响微乎其微，因此，当 $\beta = 0.9$ 指数加权平均值只关注最近十天的气温值。</p><p>再举个例子，当 $\beta = 0.98$ 时，$0.98$ 的几次方才能使这个数据足够小呢？</p><script type="math/tex; mode=display">0.98^{50}\approx\frac{1}{e}</script><p>即 50 天前数据的权重衰减为当前数据的 $\frac{1}{e}$，因此当 $\beta = 0.98$ 时，我们关注前五十个数据。</p><p>所以有一个简单的公式： $ \frac{1}{1-\beta}$ 来衡量指数滑动平均关注哪些数据。</p><h2 id="动量梯度下降法-1"><a href="#动量梯度下降法-1" class="headerlink" title="动量梯度下降法"></a>动量梯度下降法</h2><p>铺垫了这么多，什么是动量梯度下降法呢。</p><p>一言以蔽之：算法的主要思想就是<strong>计算梯度的指数加权平均</strong>，然后使用这个梯度来更新权重</p><p>具体来说，如下图所示<img src="/img/momentum_1.jpg" alt></p><p>当你使用 “batch 梯度下降法“或者 ”mini-batch 梯度下降法“时，时常会遇到这种问题：梯度方向正确，但是总会有很多的波动。而我们想加速梯度下降就需要减小这种波动，这时候就可以用到<strong>动量梯度下降法</strong>。</p><p>我们可以计算每一个<strong>参数导数的指数加权滑动平均</strong>，使用这个值来更新参数：</p><script type="math/tex; mode=display">V_{dw} = \beta V_{dw} + (1-\beta)dw \to w = w - \alpha V_{dw}\\V_{db} = \beta V_{db} + (1-\beta)db \to b = b - \alpha V_{db}</script><p>为什么要这么做呢？举个例子，假如你的梯度下降算法时这样的：</p><p><img src="/img/momentum_2.jpg" alt></p><p>那么事实上它在纵轴上的总体平均值接近于 0，因此使用动量梯度下降算法之后能够减小它在纵向的振幅，而横向的方向总是一致的，所以可以水平方向的平均值仍然较大。那么在经过动量梯度下降算法之后能够显著加速它的下降速度，或者说减弱了前往最小路径上的震荡。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动量梯度下降算法的小总结&lt;br&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络课笔记（3）</title>
    <link href="http://yoursite.com/2018/11/12/cisco/%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%AC%94%E8%AE%B03/"/>
    <id>http://yoursite.com/2018/11/12/cisco/%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%AC%94%E8%AE%B03/</id>
    <published>2018-11-12T05:00:00.000Z</published>
    <updated>2020-04-06T08:52:42.887Z</updated>
    
    <content type="html"><![CDATA[<p>IP 地址组成和 FTP 协议</p><a id="more"></a><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="IP：Internet-protocol因特网协议"><a href="#IP：Internet-protocol因特网协议" class="headerlink" title="IP：Internet protocol因特网协议"></a>IP：Internet protocol因特网协议</h2><p>作用：用于标识网络中每一个节点（路由器、终端设备：PC、server、PDA、AP访问点）。</p><p>IP协议共有16个版本，常用版本ipv4和ipv6。</p><p><code>Ipv4</code>：目前国际通用数据封装格式，地址使用点分十进制表示，例如：192.168.1.1，共有32位二进制，分为4段，每段8位。<code>地址空间：2^32=4294967296</code></p><p><code>Ipv6</code>：未来网络地址空间，2018年底中国预计8000W用户。地址使用“:”分成8段，每段16位，用十六进制表示，例如：2001:2002:2003:2004:2005:abcd：abcd:1，共128位二进制。<code>地指空间：2^128≈撒哈拉大沙漠的沙子</code></p><h2 id="网络中常用进制："><a href="#网络中常用进制：" class="headerlink" title="网络中常用进制："></a>网络中常用进制：</h2><p>二进制：0、1</p><p>十进制：0——9</p><p>十六进制：0——9，A——F</p><p>十进制<code>192</code> = 二进制<code>1100 0000</code></p><div class="table-container"><table><thead><tr><th></th><th>2^7</th><th>2^6</th><th>2^5</th><th>2^4</th><th>2^3</th><th>2^2</th><th>2^1</th><th>2^0</th></tr></thead><tbody><tr><td></td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr><tr><td>255</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>192</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>168</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>172</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><h2 id="IPV4地址组成："><a href="#IPV4地址组成：" class="headerlink" title="IPV4地址组成："></a>IPV4地址组成：</h2><p>网络位<code>network</code>+主机位<code>host</code></p><p>掩码：mask，用于确定ip地址中网络位。通过二进制的与运算得到网络位，ip地址与掩码进行“相与”。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IP地址：192.168.1.1</span><br><span class="line"></span><br><span class="line">IP掩码：255.255.255.0</span><br></pre></td></tr></table></figure><p>即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网络位：192.168.1</span><br><span class="line">主机位：1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>类别</th><th>前八位</th><th>十进制掩码</th><th>书写掩码</th></tr></thead><tbody><tr><td>Class A</td><td>0xxx xxxx (0-127)</td><td>255.0.0.0</td><td>/8</td></tr><tr><td>Class B</td><td>10xx xxxx (128-191)</td><td>255.255.0.0</td><td>/16</td></tr><tr><td>Class C</td><td>110x xxxx (192-223)</td><td>255.255.255.0</td><td>/24</td></tr><tr><td>Class D</td><td>1110 xxxx (224-239)</td><td>（组播地址范围）</td><td></td></tr><tr><td>Class E</td><td>1111 xxxx (240-255)</td><td>（科研使用）</td></tr></tbody></table></div><p>特殊IP地址：</p><p>0.0.0.0 ：代表所有网络</p><p>127.0.0.1：代表本地回环地址</p><p>255.255.255.255：代表所有主机，国际规定广播地址。</p><p>主机位全0地址：代表本网段所有子网</p><p>主机位全1地址：代表本网段所有主机，本网段广播地址</p><p>以上地址不可用。</p><p>一个网段可以容纳的主机数量：2^n - 2（n是主机位位数，“-2”剔除每个网段全0和全1地址）</p><p>举例：192.168.1.0/24网段</p><p>可用主机数量：2^8 - 2=254 </p><p>2^n- 2≥200，n≥8，掩码/24</p><h2 id="VLSM：variable-length-sunets-mask（可变长子网掩码）"><a href="#VLSM：variable-length-sunets-mask（可变长子网掩码）" class="headerlink" title="VLSM：variable length sunets mask（可变长子网掩码）"></a>VLSM：variable length sunets mask（可变长子网掩码）</h2><p>举例：</p><p>某集团现有8个部门：</p><p>研发部：50人</p><p>技术支持：20人</p><p>销售部：50人</p><p>市场部：20人</p><p>人力资源部：10人</p><p>财务部：5人</p><p>董事会：8人</p><p>后勤保障：5</p><p>规划网络：192.168.1.0/24</p><p>思考1：正常划分8个网段，/27，每个网段：2^5 - 2=30</p><p>思考2：先满足人数最多的部门（研发和销售）</p><p>2^n - 2≥50，n≥6，掩码/26</p><p>由/24变成/26，划分4个网段：</p><p>192.168.1.0/26     62   研发部  50  剩 12</p><p>192.168.1.64/26    62   销售部  50  剩 12</p><p>192.168.1.128/26   62  （已用思考3）<br> 192.168.1.192/26   62  （已用思考4）</p><p>思考3：满足剩下最大部门人数（技术支持和市场20）</p><p>192.168.1.128/26   </p><p>2^n - 2≥20，n≥5，掩码/27</p><p>由/26变成/27，划分两个网段</p><p>192.168.1.10xx xxxx/26</p><p>192.168.1.100x xxxx/27   192.168.1.128/27  30 技术支持 20 剩10</p><p>192.168.1.101x xxxx/27   192.168.1.160/27  30 市场     20 剩 10</p><p>思考4：满足剩下最大部门（HR部门10）</p><p>192.168.1.192/26</p><p>2^n - 2 ≥10，n≥4 ，掩码/28</p><p>由/26变成/28，划分4个网段：</p><p>192.168.1.11xx xxxx/26</p><p>192.168.1.1100 xxxx/28  192.168.1.192/28  14  HR 10 剩 4</p><p>192.168.1.1101 xxxx/28  192.168.1.208/28  14  董事 8  剩 6</p><p>192.168.1.1110 xxxx/28  192.168.1.224/28  14  财务 5  剩 9</p><p>192.168.1.1111 xxxx/28  192.168.1.240/28  14  后勤 5  剩 9</p><h2 id="FTP（File-Transfer-Protocol）文件传输协议"><a href="#FTP（File-Transfer-Protocol）文件传输协议" class="headerlink" title="FTP（File Transfer Protocol）文件传输协议"></a>FTP（File Transfer Protocol）文件传输协议</h2><p>作用：传输较大的文本文件以及执行程序</p><p>访问FTP服务器：</p><ol><li><p>FTP服务器开启服务并设置权限</p></li><li><p>终端主机访问FTP服务器（ftp + ip地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pc&gt;ftp + ip   //进入ftp服务器</span><br><span class="line">输入：用户名</span><br><span class="line">输入：密码</span><br><span class="line">ftp&gt;  //已在ftp中</span><br></pre></td></tr></table></figure></li></ol><h2 id="TFTP：普通文件传输协议"><a href="#TFTP：普通文件传输协议" class="headerlink" title="TFTP：普通文件传输协议"></a>TFTP：普通文件传输协议</h2><p>作用：传输较小的文本或者执行文件，例如：设备的IOS（bin文件）</p><p>用途：用于设备的IOS更新和备份</p><p>备份IOS：</p><ol><li><p>打开TFTP服务器，保证TFTP服务器中存在IOS。</p></li><li><p>路由器、交换机、电脑配置IP地址使能够通信</p></li><li><p>进行IOS的备份/升级（先备份，后升级）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router# copy flash: tftp:</span><br><span class="line">输入：IOS名称</span><br><span class="line">输入：远端服务器地址</span><br></pre></td></tr></table></figure><p>升级IOS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//先查看设备内存是否足够存储新的IOS</span><br><span class="line">show flansh</span><br><span class="line">//如果空间不够，需要删除现在的ios，来存储新的IOS</span><br><span class="line">delete flash: 现在的IOS名称//删除ISO（慎用！！）</span><br><span class="line">//特权模式下：</span><br><span class="line">Router# copy tftp: flash:</span><br><span class="line">输入：服务器地址</span><br><span class="line">输入：新的IOS名称</span><br><span class="line">Router# reload     </span><br><span class="line">//重启，运行新的IOS</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>应用层协议</th><th>FTP</th><th>HTTP</th><th>TELNET</th><th>DNS</th><th>TFTP</th><th>DHCP</th><th>RIP</th></tr></thead><tbody><tr><td>端口号</td><td>21</td><td>80</td><td>23</td><td>53</td><td>69</td><td>67/68</td><td>520</td></tr><tr><td>传输协议</td><td>TCP</td><td>TCP</td><td>TCP</td><td>TCP/UDP</td><td>UDP</td><td>UDP</td><td>UDP</td></tr><tr><td>协议号</td><td>6</td><td>6</td><td>6</td><td>6/17</td><td>17</td><td>17</td><td>17</td></tr><tr><td>网络层协议</td><td>IP</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IP 地址组成和 FTP 协议&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络课笔记（2）</title>
    <link href="http://yoursite.com/2018/11/11/cisco/%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2018/11/11/cisco/%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%AC%94%E8%AE%B02/</id>
    <published>2018-11-11T08:43:23.000Z</published>
    <updated>2020-04-06T08:53:11.410Z</updated>
    
    <content type="html"><![CDATA[<p>交换机的使用，数据链路层的原理以及 VLAN 之间的通信。</p><a id="more"></a><h1 id="二层技术：数据链路层（交换机）"><a href="#二层技术：数据链路层（交换机）" class="headerlink" title="二层技术：数据链路层（交换机）"></a>二层技术：数据链路层（交换机）</h1><h2 id="交换机功能"><a href="#交换机功能" class="headerlink" title="交换机功能"></a>交换机功能</h2><h3 id="（1）mac地址学习"><a href="#（1）mac地址学习" class="headerlink" title="（1）mac地址学习"></a>（1）mac地址学习</h3><p>原理：交换机转发数据帧的依据是mac地址转发表（相当于路由器中的路由表routing-table）mac-address-table。</p><p>过程：</p><ol><li>默认交换机mac地址表为空（null）</li><li>当设备开始发送数据帧，交换机会将设备的MAC地址与交换机的本地接口进行映射，形成mac地址转发表。</li></ol><p>查看mac地址转发表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Show mac-address-table     //交换机特权模式下查看mac地址转发表</span><br><span class="line">Mac address-table aging-time + 时间/s    //修改老化时间</span><br><span class="line">Clear mac-address-table     //清理mac地址转发表</span><br></pre></td></tr></table></figure></p><p><img src="/img/mac地址表.png" alt="mac地址表"></p><h3 id="（2）-数据帧的转发和过滤"><a href="#（2）-数据帧的转发和过滤" class="headerlink" title="（2） 数据帧的转发和过滤"></a>（2） 数据帧的转发和过滤</h3><h3 id="（3）二层网络防环"><a href="#（3）二层网络防环" class="headerlink" title="（3）二层网络防环"></a>（3）二层网络防环</h3><p>产生环路的原因：为了备份链路</p><p>环路引起的问题：</p><ol><li>数据帧重复</li><li>mac地址表不稳定</li><li>广播风暴（二层网络最严重的问题）<br> 广播风暴产生的原因：<ul><li>未知单播泛洪（unknown unicast flooding）</li><li>组播数据帧（multicast）</li><li>广播数据帧</li></ul></li></ol><p>防环机制：生成树spanning-tree protocol（STP）</p><p>原理：将环路中某些接口进行逻辑上的阻塞blocking，形成断开环路的效果，当有效链路发生物理上的down，那么blocking接口会进入forwarding转发状态（需要50s）。</p><h2 id="VLAN（Virtual-Local-Area-Network）：虚拟局域网"><a href="#VLAN（Virtual-Local-Area-Network）：虚拟局域网" class="headerlink" title="VLAN（Virtual Local Area Network）：虚拟局域网"></a>VLAN（Virtual Local Area Network）：虚拟局域网</h2><p>作用：将交换机上的网络进行逻辑上的分段（一个VLAN = 一个广播域 = 一个网段）</p><p>优点：分段，灵活，安全</p><p>VLAN范围：<code>0-4095</code></p><ul><li><code>0、4095</code>：系统保留</li><li><code>2-1001</code>：以太网常用VLAN</li><li><code>1002-1005</code>：令牌环网和FDDI</li><li><code>1024-4094</code>：扩展VLAN，只能用于三层以上交换机使用，思科设备的VTP模式为透明模式</li></ul><p>VLAN配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//全局模式下</span><br><span class="line">valn 10   //创建vlan，vlan-ID为10</span><br><span class="line">name  TECH  //命名vlan，名字TECH。（可选）</span><br><span class="line">vlan  20</span><br><span class="line">name  SALE</span><br><span class="line">Vlan  30</span><br><span class="line">Name  HR</span><br><span class="line">Vlan  40</span><br><span class="line">Name  COMM</span><br><span class="line">...... </span><br><span class="line">//接口划入vlan：全局模式下</span><br><span class="line"></span><br><span class="line">Int  f0/1</span><br><span class="line">Switchport  mode  access    //设置交换机接口模式为接入模式</span><br><span class="line">Switchport  access  vlan  10  //接口接入vlan 10</span><br><span class="line"></span><br><span class="line">Int  f0/2</span><br><span class="line">Sw  mo  ac</span><br><span class="line">Sw  ac  vlan  20</span><br><span class="line"></span><br><span class="line">Int  f0/3</span><br><span class="line">Sw  mo  ac</span><br><span class="line">Sw  ac  vlan  30</span><br><span class="line"></span><br><span class="line">Int  f0/4</span><br><span class="line">Sw  mo  ac</span><br><span class="line">Sw  ac  vlan  40</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//查看vlan信息：</span><br><span class="line">show vlan brief</span><br></pre></td></tr></table></figure></p><p><img src="/img/CCIE/vlan_brief.png" alt="vlan_brief"></p><h2 id="干道：trunk"><a href="#干道：trunk" class="headerlink" title="干道：trunk"></a>干道：trunk</h2><p>作用：用于封装交换机之间的链路，用于不同vlan数据帧打标记。<br><img src="/img/CCIE/trunk链路.png" alt></p><p><strong>Trunk打标记协议</strong>：<code>IEEE802.1q</code>和<code>ISL</code></p><ol><li><strong>IEEE802.1q</strong>：共有标准，支持不同的厂商之间交换vlan信息，也称为dot1q，共有4个字节，数据帧格式如下表：<br>| 2字节      | 3位         | 1位      | 12位         |<br>| ————— | —————- | ———— | —————— |<br>| 以太网类型 | 优先级位0-7 | 令牌环位 | VLAN-ID 4069 |</li><li><strong>ISL</strong>：思科私有标准，共有30个字节，前26字节，后4字节，中间只有10位可用于VLAN-ID的标记（2^10=1024）。<br> <img src="/img/CCIE/ISL.png" alt="Alt text"></li></ol><p><strong>Trunk配置</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Int  range  f0/5 - 6  ///同时进入f0/5和f0/6</span><br><span class="line">Switchport  trunk  encapsulation  dot1q  ///交换机干道封装选择dot1q(IEEE 802.1q)，在二层交换机无法配置</span><br><span class="line">Switchport  mode  trunk ///交换机接口模式为trunk模式（on模式），二层交换机只配一条</span><br><span class="line">//简写：</span><br><span class="line">Int  ran  f0/5 - 6</span><br><span class="line">Sw  tr  en  do </span><br><span class="line">Sw  mo  tr</span><br></pre></td></tr></table></figure></p><p><strong>Trunk干道</strong>：接口一旦成为Trunk干道之后，将不再属于任何vlan。当查看<code>show  vlan  brief</code>时，无法看到<strong>Trunk</strong>接口。</p><p><strong>查看Trunk干道</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Show  int  trunk</span><br></pre></td></tr></table></figure></p><p><img src="/img/CCIE/查看trunk干道.png" alt="Alt text"></p><h2 id="VLAN间通信：单臂路由"><a href="#VLAN间通信：单臂路由" class="headerlink" title="VLAN间通信：单臂路由"></a>VLAN间通信：单臂路由</h2><p><img src="/img/CCIE/单臂路由.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//交换机上的配置：</span><br><span class="line">Int  f0/7   //连接路由器的接口</span><br><span class="line">Sw  mo  tr   //封装trunk，打标记</span><br><span class="line"></span><br><span class="line">//路由器上配置：</span><br><span class="line">Int  f0/0  //进入母接口</span><br><span class="line">no  sh   //打开接口</span><br><span class="line">Int  f0/0.1  //创建f0/0的子接口，子接口号为f0/0.1</span><br><span class="line">encapsulation  dot1q  10  //封装标记10，用于识别vlan 10的数据</span><br><span class="line">Ip  add  192.168.10.254  255.255.255.0  //配置vlan 10网关</span><br><span class="line">Int  f0/0.2</span><br><span class="line">en  do  20</span><br><span class="line">Ip  add  192.168.20.254  255.255.255.0  </span><br><span class="line">Int  f0/0.3</span><br><span class="line">en  do  30</span><br><span class="line">Ip  add  192.168.30.254  255.255.255.0</span><br><span class="line">Int  f0/0.4</span><br><span class="line">en  do  40</span><br><span class="line">Ip  add  192.168.40.254  255.255.255.0</span><br></pre></td></tr></table></figure></p><h2 id="VTP：vlan-trunk-protocol"><a href="#VTP：vlan-trunk-protocol" class="headerlink" title="VTP：vlan  trunk  protocol"></a>VTP：vlan  trunk  protocol</h2><p><strong>作用</strong>：通过交换机之间的trunk干道进行不同交换机之间vlan信息的传递，简化交换机vlan的配置量。</p><p><strong>VTP配置</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//VTP服务器端配置：</span><br><span class="line">vtp  domain  CCIE  //创建vtp同步域，域名为CCIE，必须相同</span><br><span class="line">vtp  mode  server  //设置为服务器模式</span><br><span class="line">vtp  version  2    //激活vtpv2，只在服务器模式设备配置</span><br><span class="line">vtp  password  cisco  //设置vtp的密码，注意空格（可选）</span><br><span class="line"></span><br><span class="line">//VTP客户端配置：</span><br><span class="line">vtp  domain  CCIE</span><br><span class="line">vtp  mode  client</span><br><span class="line">vtp  password  cisco</span><br></pre></td></tr></table></figure></p><p><strong>查看vtp同步</strong>：<code>client</code>端<br><img src="/img/CCIE/VTP同步1.png" alt="Alt text"><br><img src="/img/CCIE/VTP同步2.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换机的使用，数据链路层的原理以及 VLAN 之间的通信。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络课笔记（1）</title>
    <link href="http://yoursite.com/2018/10/30/cisco/%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2018/10/30/cisco/%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%AC%94%E8%AE%B01/</id>
    <published>2018-10-30T05:00:00.000Z</published>
    <updated>2020-04-06T08:52:27.635Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网路的基本结构以及思科路由器的使用方法。</p><a id="more"></a><h1 id="OSI七层网络协议"><a href="#OSI七层网络协议" class="headerlink" title="OSI七层网络协议"></a>OSI七层网络协议</h1><div class="table-container"><table><thead><tr><th>os层次</th><th style="text-align:left">作用</th><th>协议</th><th>设备</th><th>数据</th></tr></thead><tbody><tr><td>应用层</td><td style="text-align:left">为用户提供应用端口</td><td>http、https、ftp、DNS</td><td></td><td>message</td></tr><tr><td>表示层</td><td style="text-align:left">为数据提供加密压缩服务</td><td>加密：AES、DES、3DES压缩：zip</td><td></td><td>message</td></tr><tr><td>会话层</td><td style="text-align:left">为数据处理提供平台</td><td>os：ios（internet operating system 思科的）</td><td></td><td>message</td></tr><tr><td>传输层</td><td style="text-align:left">为数据提供可靠和不可靠传输</td><td>TCP、UDP、SPX</td><td></td><td>Fragment数据段</td></tr><tr><td>网络层</td><td style="text-align:left">为数据提供逻辑寻址，提供转发差错控制和纠正</td><td>IP、IPX（Novell）、Appleta</td><td>路由器</td><td>Packet数据包</td></tr><tr><td>数据链路层</td><td style="text-align:left">为数据提供物理寻址，提供交换功能，差错控制无法纠正</td><td>LAN：IEEE802.3、IEEE802.5、FDDI WAN：PPP、Frame-relay、HDLC</td><td>交换机（switch）、桥（bridge）</td><td>Frame数据帧</td></tr><tr><td>物理层</td><td style="text-align:left">为数据传输定义限速，线缆，电压</td><td>RS232、RJ45X.25</td><td>集线器Hub、中继器repeater、调制解调器modem</td><td>数据位</td></tr></tbody></table></div><h1 id="路由器的使用"><a href="#路由器的使用" class="headerlink" title="路由器的使用"></a>路由器的使用</h1><h2 id="连接真机设备"><a href="#连接真机设备" class="headerlink" title="连接真机设备"></a>连接真机设备</h2><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>secure CRT（WIN7及以上系统需要，XP自带超级终端）</p><p>RS232转接线驱动</p><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>console线，RS232-USB转接线、双绞线（直连和交叉各一根，直连用于交换机，交叉用于路由器）。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>使用console线链接设备的“console”端口，RS-232连接电脑</li><li>安装RS-232转接线驱动，电脑查看端口。      <code>“控制面板”--“设备管理器”--“端口（com和LPT）”</code></li><li>打开CRT，使用CRT桥接         <code>“快速连接”--“协议：serial”--“端口com5”--“波特率9600”--“连接”</code></li></ol><h2 id="设备模式"><a href="#设备模式" class="headerlink" title="设备模式"></a>设备模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; //用户模式，权限为0，查看设备简单信息。</span><br><span class="line"></span><br><span class="line"># //特权模式，中等权限，可以对设备进行简单修改。</span><br><span class="line"></span><br><span class="line">(config)# //全局模式，可以对设备做任何操作。</span><br></pre></td></tr></table></figure><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;enable //进入特权  可缩写为`en`</span><br><span class="line"></span><br><span class="line">#configure terminal  //进入全局，可缩写为`conf t`</span><br><span class="line"></span><br><span class="line">exit //逐级退出</span><br><span class="line"></span><br><span class="line">end //直接退出到特权，只能退出到特权，快捷方式为`ctrl+z`</span><br></pre></td></tr></table></figure><h2 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h2><h3 id="1-enable密码（用于保护特权模式）："><a href="#1-enable密码（用于保护特权模式）：" class="headerlink" title="1.enable密码（用于保护特权模式）："></a>1.enable密码（用于保护特权模式）：</h3><h4 id="全局模式下："><a href="#全局模式下：" class="headerlink" title="全局模式下："></a>全局模式下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enable password + 密码1 //明文密码，层级为0。</span><br><span class="line"></span><br><span class="line">enable secret + 密码2 //密文密码，层级为5.。</span><br></pre></td></tr></table></figure><h4 id="特权模式下："><a href="#特权模式下：" class="headerlink" title="特权模式下："></a>特权模式下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write //保存配置，可简写为wr</span><br></pre></td></tr></table></figure><h4 id="查看设备配置"><a href="#查看设备配置" class="headerlink" title="查看设备配置"></a>查看设备配置</h4><p>在特权模式下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show running-config //查看设备当前运行的配置，可简写为sh run</span><br></pre></td></tr></table></figure></p><h3 id="2-控制台密码（用于保护使用后门接入）"><a href="#2-控制台密码（用于保护使用后门接入）" class="headerlink" title="2.控制台密码（用于保护使用后门接入）"></a>2.控制台密码（用于保护使用后门接入）</h3><h4 id="全局模式下：-1"><a href="#全局模式下：-1" class="headerlink" title="全局模式下："></a>全局模式下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Line cosole 0</span><br><span class="line">password +密码  ///设置密码</span><br><span class="line">login  /// 激活密码，登录时使用</span><br></pre></td></tr></table></figure><p>特权模式下再保存密码</p><h3 id="3-远程登录密码（用于保护Telnet远程登录设备）"><a href="#3-远程登录密码（用于保护Telnet远程登录设备）" class="headerlink" title="3.远程登录密码（用于保护Telnet远程登录设备）"></a>3.远程登录密码（用于保护Telnet远程登录设备）</h3><h4 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h4><h5 id="全局模式下：-2"><a href="#全局模式下：-2" class="headerlink" title="全局模式下："></a>全局模式下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int f0/0 //进入接口，电脑连接的接口。</span><br><span class="line"></span><br><span class="line">no shutdown //打开接口，默认路由器的接口是关闭状态。</span><br><span class="line"></span><br><span class="line">ip address 192.168.1.1 255.255.255.0 //配置ip地址</span><br></pre></td></tr></table></figure><h5 id="电脑配置："><a href="#电脑配置：" class="headerlink" title="电脑配置："></a>电脑配置：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“控制面板”——“网络和共享中心”——“更改适配器设置”——右击“本地连接”或者“以太网”——“属性”——“Internet协议版本4”——修改ip地址——确定——确定</span><br></pre></td></tr></table></figure><h4 id="测试路由器和电脑连通性"><a href="#测试路由器和电脑连通性" class="headerlink" title="测试路由器和电脑连通性"></a>测试路由器和电脑连通性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win+r——cmd——ping 192.168.1.1</span><br></pre></td></tr></table></figure><h4 id="路由器远程登录开启"><a href="#路由器远程登录开启" class="headerlink" title="路由器远程登录开启"></a>路由器远程登录开启</h4><h5 id="全局模式下"><a href="#全局模式下" class="headerlink" title="全局模式下"></a>全局模式下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line vty 0  4  ///进入虚拟终端，打开0--4线程</span><br><span class="line">password  xxxxx   ///配置密码</span><br><span class="line">login    ///激活密码</span><br><span class="line">电脑远程登录路由器：</span><br><span class="line">win+r ——— cmd——Telnet 192.1681.1——输入远程登录密码——再输入enable密码</span><br></pre></td></tr></table></figure><h2 id="网络设备密码破解和恢复"><a href="#网络设备密码破解和恢复" class="headerlink" title="网络设备密码破解和恢复"></a>网络设备密码破解和恢复</h2><p><img src="/img/CCIE/路由器存储方式.png" alt="effect"></p><h3 id="路由器密码破解和恢复："><a href="#路由器密码破解和恢复：" class="headerlink" title="路由器密码破解和恢复："></a>路由器密码破解和恢复：</h3><ol><li><p>设备硬重启（关、开电源），然后使用ctrl+c或者ctrl+break阻断设备加载NVRAM中的配置.(不加载密码)</p><p><img src="/img/CCIE/路由器硬重启.png" alt="effect"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rommon 1&gt; confreg  0x2142   //修改寄存器的值，使设备开机时不加载NVRAM。</span><br><span class="line">rommon 2&gt; boot  //继续进行开机</span><br></pre></td></tr></table></figure></li><li><p>进入没有配置的系统，手动将保存在NVRAM中的配置拷贝到当前运行，NVRAM——&gt;RAM.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//特权模式下：</span><br><span class="line">copy  startup-config    running-config  </span><br><span class="line">         （NVRAM）          （RAM）</span><br><span class="line">//查看运行配置中的密码信息</span><br><span class="line">show  running-config  //查看当前运行的配置（wr之前的内容）</span><br></pre></td></tr></table></figure><p><img src="/img/CCIE/show_running_config.png" alt="effect"></p></li><li><p>通过客户（甲方）请求是否修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//全局模式下：</span><br><span class="line">enable  password  +密码  //设置新的密码，覆盖老的。</span><br><span class="line">enable  secret  +密码</span><br></pre></td></tr></table></figure></li><li><p>将寄存器值改回0x2102，使设备开机时依然加载NVRAM中的配置，然后保存，软重启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//全局模式下：</span><br><span class="line">config-register  0x2102   ///修改寄存器</span><br><span class="line">特权模式下：</span><br><span class="line">wr        ///保存</span><br><span class="line">reload   ///软重启</span><br></pre></td></tr></table></figure></li></ol><h3 id="交换机密码破解和恢复："><a href="#交换机密码破解和恢复：" class="headerlink" title="交换机密码破解和恢复："></a>交换机密码破解和恢复：</h3><ol><li><p>硬重启，关开电源，按住mode键5-10s，直到设备出现“switch:”字样。</p></li><li><p>初始化flash，查看保存文件，然后修改文件后缀，使设备无法加载保存配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Switch：flash_init   //初始化</span><br><span class="line">Switch：dir  flash：  //查看文件，查找“config.text”</span><br><span class="line">Switch：rename  flash:config.text   flash:config.old   //修改后缀</span><br><span class="line">Switch：reset   //重启设备</span><br></pre></td></tr></table></figure></li><li><p>进入空配置设备，将后缀改回，使设备读取，手动加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//特权模式下：</span><br><span class="line">Rename  flash:config.old   flash:config.text</span><br><span class="line">Copy  flash:config.text  running-config</span><br></pre></td></tr></table></figure></li><li><p>查看/修改密码，保存并重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//全局模式下：</span><br><span class="line">enable  password  + 密码</span><br><span class="line">enable  secret  + 密码</span><br><span class="line">//特权模式下：</span><br><span class="line">wr</span><br><span class="line">reload</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网路的基本结构以及思科路由器的使用方法。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://yoursite.com/2018/07/31/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2018/07/31/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</id>
    <published>2018-07-30T16:00:04.000Z</published>
    <updated>2020-03-31T05:33:24.334Z</updated>
    
    <content type="html"><![CDATA[<p><strong>列表（list）</strong>是python里面内置的一种数据类型，是一种有序集合，可以随时添加删除排序其中的元素。 </p><p><strong>元组（tuple）</strong>和列表非常类似，但是元组一旦初始化就不能修改了。</p><p><strong>字典（dict）</strong>全称dictionary，使用<strong>键-值（key-value）</strong>存储，具有极快的查找速度。</p><a id="more"></a><h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h1><p>列表（list）是python里面内置的一种数据类型，是一种有序集合，可以随时添加删除排序其中的元素。 </p><h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><p>定义列表操作如下：</p><blockquote><p><code>classmates = [ &#39;Jack&#39; , &#39;Tony&#39; , &#39;Richard&#39; ]</code> </p></blockquote><p>（python大部分情况下对于字符串的引用中单引号<code>&#39;</code>和双引号<code>&quot;</code>的用法相同）</p><p>变量<code>classmates</code>就是一个列表，列表里存放的是<code>Jack</code> <code>Tony</code> <code>Richard</code> 三个字符串类型的学生姓名，当然列表里的元素当然也可以是不同的数据类型。</p><p>用<code>len()</code>函数可以获取列表元素的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;len(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>通过下标来访问列表中的元素，下标从0开始计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;classmates[<span class="number">0</span>]</span><br><span class="line"><span class="string">'Jack'</span></span><br><span class="line">&gt;&gt;&gt;classmates[<span class="number">1</span>]</span><br><span class="line"><span class="string">'Tony'</span></span><br><span class="line">&gt;&gt;&gt;classmates[<span class="number">2</span>]</span><br><span class="line"><span class="string">'Richard'</span></span><br></pre></td></tr></table></figure><h2 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h2><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>列表自带有<code>append()</code>函数，默认将新元素追加到列表的最后，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'Richard'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'我是新来的'</span>)</span><br><span class="line">&gt;&gt;&gt;classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br></pre></td></tr></table></figure></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>当想要将元素插入到列表的任意地方时，可以使用<code>insert()</code>函数，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">2</span>,<span class="string">'我要插在Richard的前面！'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'我要插在Richard的前面！'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br></pre></td></tr></table></figure><p><code>insert()</code>需要传入两个数据，一个是插入的位置，一个为插入的内容，插入之后，后面的数据下标自动加一。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改其实就想当于直接赋值给该位置的元素，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'我要插在Richard的前面！'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">2</span>] = <span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除可以使用<code>pop(i)</code>或者<code>del(i)</code>方法，其<code>i</code>为元素的下标。</p><p>其中<code>del classmates(1) = classmates.pop(1)</code>，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'Richard'</span>, <span class="string">'我要插在Richard的前面！'</span>, <span class="string">'我是新来的'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> classmates[<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>, <span class="string">'我是新来的'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">4</span>)</span><br><span class="line"><span class="string">'我是新来的'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br></pre></td></tr></table></figure><p> 其中，<code>classmates.pop()</code>代表默认删除列表最后一个元素。</p><p>如果要删除整个列表，也只需要<code>del classmates</code>即可</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片批量获取列表中的元素，例如此时<code>classmates</code>中所包含的元素为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br></pre></td></tr></table></figure><p>此时想要获取前三个元素，可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><p>此时可以发现切片的原则是<strong>顾头不顾尾</strong> ，即上面的例子中，只从索引<code>0</code> 开始取，到索引<code>3</code>为止，但是不包括索引<code>3</code>，即索引<code>0</code> 、<code>1</code> 、<code>2</code>。</p><p>如果一个索引是<code>0</code>，还可以省略，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><p>切片还可以倒过来切，即从最后的元素开始取值，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><p>这即是表示从左往右数倒数第二个至倒数第一个的切片。</p><p>那么问题来了，以上这种倒着切片无法取到最后一个数，怎么取到最后一个数呢，很简单如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>:]</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br></pre></td></tr></table></figure><p>最后一位空着即可进行最后一位的切片。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">首先创建一个<span class="number">0</span><span class="number">-99</span>的数列：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(range(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br><span class="line">可以通过切片轻松取出某一段数列，比如前<span class="number">10</span>个数：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">10</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">后<span class="number">10</span>个数：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-10</span>:]</span><br><span class="line">[<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line">前<span class="number">11</span><span class="number">-20</span>个数：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line"></span><br><span class="line">前十个数，每两个取一个数：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">所有数，每<span class="number">5</span>个取一个：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</span><br><span class="line"></span><br><span class="line">原数列：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>前面已经讲过可以通过<code>classnates[i]</code> 来查找<code>classmates</code> 中第<strong>i</strong> 个元素是什么，但如果想知道某个元素在列表中的具体位置可以使用<code>index()</code>函数来解决，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.index(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>如果一个列表中有多个同名的元素，可以通过<code>count()</code>函数来统计，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'hello'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>, <span class="string">'hello'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.count(<span class="string">'hello'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="排序和翻转"><a href="#排序和翻转" class="headerlink" title="排序和翻转"></a>排序和翻转</h3><p><code>sort()</code>函数为按照ascll码顺序为列表中的数据排序</p><p><code>reverse()</code>函数是将列表翻转，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'Richard'</span>, <span class="string">'hello'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'hello'</span>, <span class="string">'Richard'</span>, <span class="string">'hello'</span>, <span class="string">'Tony'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Richard'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>扩展，即有两个列表<code>calssmates</code>和<code>classmates2</code> ,将一个列表合并到另一个列表中，默认合并至末尾，并且被合并的列表仍然<strong>存在</strong>，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.extend(classmates2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Richard'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'hello'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><p>在讲拷贝之前我们首先要知道，python中存储列表实际上是以内存地址的方式存储的，所以<code>copy</code>的时候也只是copy一块内存地址，而这个指针指向的真正的内存地址中的内容改变时，copy的变量也会随着改变，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append([<span class="string">'aaaaaaa'</span>,<span class="string">'bbbbbbb'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Richard'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'hello'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'aaaaaaa'</span>, <span class="string">'bbbbbbb'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates2 = classmates.copy()     <span class="comment">#classmates是classmates的一份拷贝</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates2</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Richard'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'hello'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'aaaaaaa'</span>, <span class="string">'bbbbbbb'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">3</span>] = <span class="string">'你好'</span>               <span class="comment">#将classmates中的‘hello’改为‘你好’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">9</span>][<span class="number">0</span>] = <span class="string">'hello'</span>   <span class="comment">#将classmates中的列表中的aaa改为‘hello’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Richard'</span>, <span class="string">'Tony'</span>, <span class="string">'你好'</span>, <span class="string">'hello'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'hello'</span>, <span class="string">'bbbbbbb'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates2</span><br><span class="line">[<span class="string">'Jack'</span>, <span class="string">'Richard'</span>, <span class="string">'Tony'</span>, <span class="string">'hello'</span>, <span class="string">'hello'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'hello'</span>, <span class="string">'bbbbbbb'</span>]]</span><br><span class="line">                   <span class="comment">#可以看到，classmates2中的数据没有改，而列表中的列表数据改了</span></span><br></pre></td></tr></table></figure><h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h1><p>元组和列表非常类似，但是元组一旦初始化就不能修改了。</p><h2 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h2><p>定义元组的操作如下：</p><p><code>classmates = (&#39;Jack&#39; , &#39;Tony&#39; , &#39;Richard&#39;)</code> </p><p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和列表是一样的，你可以正常地使用<code>classmates[0]</code>，<code>classmates[-1]</code>，但不能赋值成另外的元素。</p><p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p><strong>注意</strong>：要定义一个只有1个元素的tuple，如果你这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>定义的不是tuple，是<code>1</code>这个数！这是因为括号<code>()</code>既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是<code>1</code>。</p><p>所以，只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p>最后来看一个“可变的”tuple：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</span><br></pre></td></tr></table></figure><p>这个tuple定义的时候有3个元素，分别是<code>&#39;a&#39;</code>，<code>&#39;b&#39;</code>和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？</p><p>表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>&#39;a&#39;</code>，就不能改成指向<code>&#39;b&#39;</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p><h2 id="元组操作"><a href="#元组操作" class="headerlink" title="元组操作"></a>元组操作</h2><p>元组只有两个方法：一个是<code>count()</code>，一个是<code>index</code></p><h1 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h1><p>dict全称dictionary，在其他语言中也称为map</p><p>字典使用<strong>键-值（key-value）</strong>存储，具有极快的查找速度。 </p><h2 id="定义字典"><a href="#定义字典" class="headerlink" title="定义字典"></a>定义字典</h2><p>初始化一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Jack'</span>:<span class="number">50</span>,<span class="string">'Tony'</span>:<span class="number">50</span>,<span class="string">'Richard'</span>:<span class="number">55</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Tony'</span>]</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p><strong>注意：定义字典时是<code>{}</code>，使用字典时是<code>[]</code>。因为使用的时候已经将它当做列表来使用了。但是字典只能通过key来使用value</strong></p><p>把数据放入dict的方法，除了初始化时指定外，还可以通过<strong>key</strong>放入： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'xwtttt'</span>] = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'xwtttt'</span>]</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>] = <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Jack'</span>]</span><br><span class="line"><span class="number">90</span></span><br></pre></td></tr></table></figure><p>如果key不存在，字典就会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'a'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>字典的特性：</p><ul><li>key唯一，所以天生去重</li><li>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。 </li><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ul><p>所以，dict是用空间来换取时间的一种方法。</p><p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。</p><p>这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。</p><p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</p><h2 id="字典操作"><a href="#字典操作" class="headerlink" title="字典操作"></a>字典操作</h2><p>字典的操作大致和列表相同（如删除等），这里只列举几个不太相同的用法</p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断某元素是否在字典中，使用in用法，返回一个布尔值。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'Jack'</span>: <span class="number">50</span>, <span class="string">'Tony'</span>: <span class="number">50</span>, <span class="string">'Richard'</span>: <span class="number">55</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Jack'</span> <span class="keyword">in</span> d  <span class="comment">#查找某元素是否在字典中，如果在，返回True，否则，返回False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'xwtttt'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断元素是否在字典中，使用get方法，返回一个None，或者Value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Jack'</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'xwtttt'</span>)  <span class="comment">#注意：返回None的时候Python的交互环境不显示结果。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'xwtttt'</span>,<span class="number">-1</span>)  <span class="comment">#此时指定一个value返回</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="多级字典的嵌套"><a href="#多级字典的嵌套" class="headerlink" title="多级字典的嵌套"></a>多级字典的嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">av_catalog = &#123;</span><br><span class="line">    <span class="string">"欧美"</span>:&#123;</span><br><span class="line">        <span class="string">"www.youporn.com"</span>: [<span class="string">"很多免费的,世界最大的"</span>,<span class="string">"质量一般"</span>],</span><br><span class="line">        <span class="string">"www.pornhub.com"</span>: [<span class="string">"很多免费的,也很大"</span>,<span class="string">"质量比yourporn高点"</span>],</span><br><span class="line">        <span class="string">"letmedothistoyou.com"</span>: [<span class="string">"多是自拍,高质量图片很多"</span>,<span class="string">"资源不多,更新慢"</span>],</span><br><span class="line">        <span class="string">"x-art.com"</span>:[<span class="string">"质量很高,真的很高"</span>,<span class="string">"全部收费,屌比请绕过"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"日韩"</span>:&#123;</span><br><span class="line">        <span class="string">"tokyo-hot"</span>:[<span class="string">"质量怎样不清楚,个人已经不喜欢日韩范了"</span>,<span class="string">"听说是收费的"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"大陆"</span>:&#123;</span><br><span class="line">        <span class="string">"1024"</span>:[<span class="string">"全部免费,真好,好人一生平安"</span>,<span class="string">"服务器在国外,慢"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">av_catalog[<span class="string">"大陆"</span>][<span class="string">"1024"</span>][<span class="number">1</span>] += <span class="string">",可以用爬虫爬下来"</span></span><br><span class="line">print(av_catalog[<span class="string">"大陆"</span>][<span class="string">"1024"</span>])</span><br><span class="line"><span class="comment">#ouput </span></span><br><span class="line">[<span class="string">'全部免费,真好,好人一生平安'</span>, <span class="string">'服务器在国外,慢,可以用爬虫爬下来'</span>]</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>注意，传入的参数<code>[1, 2, 3]</code>是一个list，而显示的<code>{1, 2, 3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p><p>重复元素在set中自动被过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>通过<code>remove(key)</code>方法可以删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;列表（list）&lt;/strong&gt;是python里面内置的一种数据类型，是一种有序集合，可以随时添加删除排序其中的元素。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元组（tuple）&lt;/strong&gt;和列表非常类似，但是元组一旦初始化就不能修改了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典（dict）&lt;/strong&gt;全称dictionary，使用&lt;strong&gt;键-值（key-value）&lt;/strong&gt;存储，具有极快的查找速度。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Markdown使用小结</title>
    <link href="http://yoursite.com/2018/07/19/markdow%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/19/markdow%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</id>
    <published>2018-07-19T04:22:00.000Z</published>
    <updated>2020-03-31T05:30:46.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h2><p><strong>Markdown</strong>是一种轻量级的标记语言，它允许人们 “使用易读易写的纯文本格式编写文档，然后转为有效的HTML文档“  </p><p><strong>Markdown</strong>也可以理解为将以<em>Markdown</em>语法编写的语言转为HTML内容的工具。<br><a id="more"></a></p><h2 id="为什么要使用Markdown"><a href="#为什么要使用Markdown" class="headerlink" title="为什么要使用Markdown"></a>为什么要使用Markdown</h2><ul><li>纯文本，所以兼容性强，所有的文本编辑器都能打开</li><li>格式清晰明了，让你能专注文本而不是排版</li><li>越来越多的主流网站开始支持<strong>Markdown</strong>写作</li><li>熟悉了以后简单到你爱不释手，word实在是太烦了 （逃~</li></ul><h2 id="Markdown的基本语法"><a href="#Markdown的基本语法" class="headerlink" title="Markdown的基本语法"></a>Markdown的基本语法</h2><p><strong>Markdown</strong>语法主要分为以下几大部分：</p><p><code>标题</code> <code>段落</code> <code>区块引用</code> <code>代码区块</code> <code>强调</code> <code>列表</code> <code>分割线</code> <code>链接</code> <code>图片</code> <code>反斜杠\</code> <code>符号</code></p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>在<strong>Markdown</strong>中，只需要在文本前面加上<code>#</code>即可创建标题，依次增加<code>#</code>则可以创建二级标题、三级标题、四级标题、无极标题、六级标题，总共六级。例如：</p><blockquote><p># 一级标题</p><p>## 二级标题</p><p>### 三级标题</p><p>#### 四级标题</p><p>##### 五级标题</p><p>###### 六级标题</p></blockquote><p>效果：</p><p><img src="/img/Snipaste_2018-07-19_13-08-00.png" alt="efftct"></p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落前后要有空行。若在段内想要强制换行的方式是使用<strong>两个以上</strong>的空格加上回车。（先看着，我试试再说~）</p><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>在每一行的开头使用符号<code>&gt;</code>,即可实现区块引用，使用<code>&gt;&gt;</code>可以嵌套引用，例如：</p><blockquote><p>> 区块引用</p><p>>&gt; 嵌套引用</p></blockquote><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>引用代码时，如果只有一段，不分行，可以使用 `将语句包裹起来，例如：</p><blockquote><p>`printf (“hello world ! “);`</p></blockquote><p>效果：</p><blockquote><p><code>printf(&quot;hello world ! &quot;);</code></p></blockquote><p>如果引用代码时有多行，可以将<strong>`</strong>置于这段代码的首行和末行，例如： </p><p><img src="/img/Snipaste_2018-07-19_13-41-43.png" alt="effect"></p><p>效果：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf (&quot;hello world ! &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>强调的内容两侧分别加上<code>*</code>或者<code>_</code>，例如：</p><blockquote><p>*斜体* ， _斜体_</p><p>*<em>粗体*</em> ， __粗体__ , </p></blockquote><p>效果：</p><blockquote><p><em>斜体</em> ， _斜体_</p><p><strong>粗体</strong> ，<strong>粗体</strong></p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>使用<code>-</code> 或者<code>+</code> 标机无序列表，例如：</p><blockquote><p>- 第一项</p><p>+ 第二项</p></blockquote><p>效果如下：</p><blockquote><ul><li>第一项</li><li>第二项</li></ul></blockquote><p>如果想要创建有序列表，只需要将上述符号换成<code>1.</code> <code>2.</code>是之类的<code>数字</code> +<code>.</code>号即可，例如：</p><blockquote><ol><li>第一项</li><li>第二项</li></ol></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线就是用三个以上的<code>*</code>，还可以用<code>-</code>和<code>_</code>。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>Markdown</strong>支持两种形式的链接语法：<strong>行内式</strong> 和 <strong>参考式</strong> 。</p><p><strong>行内式</strong>：只要在方括号后面紧接着圆括号并插入网址链接即可，例如：</p><blockquote><p>[This is my blog](<a href="https://xwtttt.github.io/" target="_blank" rel="noopener">https://xwtttt.github.io/</a>)</p></blockquote><p>效果：</p><blockquote><p><a href="https://xwtttt.github.io/" target="_blank" rel="noopener">This is my blog</a></p></blockquote><p><strong>参考式</strong>：只要在链接文字后面的括号后面再加一个方括号，而在第二个方括号里面填入用以辨识链接的标机，例如：</p><blockquote><p>[This is my blog][1]</p><p>[1]:<a href="https://xwtttt.github.io" target="_blank" rel="noopener">https://xwtttt.github.io</a></p></blockquote><p>效果：</p><blockquote><p>[This is my blog][1]</p><p>[1]:<a href="https://xwtttt.github.io" target="_blank" rel="noopener">https://xwtttt.github.io</a></p></blockquote><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>添加图片的方式和链接类似，只需要在链接的<code>[]</code>前面加上一个<code>!</code></p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠 \"></a>反斜杠 <code>\</code></h3><p>相当于<strong>转义</strong>的意思。使符号转义为普通的符号。</p><h3 id="符号"><a href="#符号" class="headerlink" title="符号  `"></a>符号  `</h3><p>标记块的意思。例如：</p><blockquote><p>`hello`</p></blockquote><p>效果如下：</p><blockquote><p><code>hello</code></p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更多的<strong>Markdown</strong>语法欢迎参看<a href="http://wowubuntu.com/markdown/#link" target="_blank" rel="noopener">Markdown 语法说明</a>，<strong>Markdown</strong>其实是一种很简单的语法，简洁优雅，熟悉了以后写文章会显得非常有条理。</p><p>至于<strong>Markdown</strong>语法编辑器网上有很多，我本人用的是<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，是一款轻量级的<strong>Markdown</strong>文本编辑器。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Markdown&quot;&gt;&lt;a href=&quot;#什么是Markdown&quot; class=&quot;headerlink&quot; title=&quot;什么是Markdown&quot;&gt;&lt;/a&gt;什么是Markdown&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种轻量级的标记语言，它允许人们 “使用易读易写的纯文本格式编写文档，然后转为有效的HTML文档“  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;也可以理解为将以&lt;em&gt;Markdown&lt;/em&gt;语法编写的语言转为HTML内容的工具。&lt;br&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
